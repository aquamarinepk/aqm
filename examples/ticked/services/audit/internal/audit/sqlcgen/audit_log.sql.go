// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_log.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const getAuditRecordByID = `-- name: GetAuditRecordByID :one
SELECT id, event_type, COALESCE(item_id, '') AS item_id, user_id, payload, source, created_at
FROM audit_log
WHERE id = $1
`

type GetAuditRecordByIDRow struct {
	ID        string                `json:"id"`
	EventType string                `json:"event_type"`
	ItemID    string                `json:"item_id"`
	UserID    string                `json:"user_id"`
	Payload   pqtype.NullRawMessage `json:"payload"`
	Source    string                `json:"source"`
	CreatedAt time.Time             `json:"created_at"`
}

func (q *Queries) GetAuditRecordByID(ctx context.Context, id string) (GetAuditRecordByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getAuditRecordByID, id)
	var i GetAuditRecordByIDRow
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.ItemID,
		&i.UserID,
		&i.Payload,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const insertAuditRecord = `-- name: InsertAuditRecord :exec
INSERT INTO audit_log (id, event_type, item_id, user_id, payload, source, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertAuditRecordParams struct {
	ID        string                `json:"id"`
	EventType string                `json:"event_type"`
	ItemID    sql.NullString        `json:"item_id"`
	UserID    string                `json:"user_id"`
	Payload   pqtype.NullRawMessage `json:"payload"`
	Source    string                `json:"source"`
	CreatedAt time.Time             `json:"created_at"`
}

func (q *Queries) InsertAuditRecord(ctx context.Context, arg InsertAuditRecordParams) error {
	_, err := q.db.ExecContext(ctx, insertAuditRecord,
		arg.ID,
		arg.EventType,
		arg.ItemID,
		arg.UserID,
		arg.Payload,
		arg.Source,
		arg.CreatedAt,
	)
	return err
}

const listAuditRecords = `-- name: ListAuditRecords :many
SELECT id, event_type, COALESCE(item_id, '') AS item_id, user_id, payload, source, created_at
FROM audit_log
ORDER BY created_at DESC
LIMIT $1
`

type ListAuditRecordsRow struct {
	ID        string                `json:"id"`
	EventType string                `json:"event_type"`
	ItemID    string                `json:"item_id"`
	UserID    string                `json:"user_id"`
	Payload   pqtype.NullRawMessage `json:"payload"`
	Source    string                `json:"source"`
	CreatedAt time.Time             `json:"created_at"`
}

func (q *Queries) ListAuditRecords(ctx context.Context, limit int32) ([]ListAuditRecordsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditRecords, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditRecordsRow{}
	for rows.Next() {
		var i ListAuditRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.ItemID,
			&i.UserID,
			&i.Payload,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditRecordsByEventType = `-- name: ListAuditRecordsByEventType :many
SELECT id, event_type, COALESCE(item_id, '') AS item_id, user_id, payload, source, created_at
FROM audit_log
WHERE event_type = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListAuditRecordsByEventTypeParams struct {
	EventType string `json:"event_type"`
	Limit     int32  `json:"limit"`
}

type ListAuditRecordsByEventTypeRow struct {
	ID        string                `json:"id"`
	EventType string                `json:"event_type"`
	ItemID    string                `json:"item_id"`
	UserID    string                `json:"user_id"`
	Payload   pqtype.NullRawMessage `json:"payload"`
	Source    string                `json:"source"`
	CreatedAt time.Time             `json:"created_at"`
}

func (q *Queries) ListAuditRecordsByEventType(ctx context.Context, arg ListAuditRecordsByEventTypeParams) ([]ListAuditRecordsByEventTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditRecordsByEventType, arg.EventType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditRecordsByEventTypeRow{}
	for rows.Next() {
		var i ListAuditRecordsByEventTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.ItemID,
			&i.UserID,
			&i.Payload,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditRecordsByUserID = `-- name: ListAuditRecordsByUserID :many
SELECT id, event_type, COALESCE(item_id, '') AS item_id, user_id, payload, source, created_at
FROM audit_log
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListAuditRecordsByUserIDParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
}

type ListAuditRecordsByUserIDRow struct {
	ID        string                `json:"id"`
	EventType string                `json:"event_type"`
	ItemID    string                `json:"item_id"`
	UserID    string                `json:"user_id"`
	Payload   pqtype.NullRawMessage `json:"payload"`
	Source    string                `json:"source"`
	CreatedAt time.Time             `json:"created_at"`
}

func (q *Queries) ListAuditRecordsByUserID(ctx context.Context, arg ListAuditRecordsByUserIDParams) ([]ListAuditRecordsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditRecordsByUserID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditRecordsByUserIDRow{}
	for rows.Next() {
		var i ListAuditRecordsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.ItemID,
			&i.UserID,
			&i.Payload,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
